// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.28;

import {Auth} from "src/core/Auth.sol";
import {IRiyzoRegistry} from "src/interfaces/hub/IRiyzoRegistry.sol";

/// @title RiyzoRegistry - Pool & Asset Registry
/// @author Riyzo Protocol
/// @notice This contract is the central registry for all pools and assets.
///         Think of it as the "phone book" for the entire protocol.
/// @dev Stores pool configurations, asset registrations, and manager permissions.
///      This is the source of truth for what pools exist and who can manage them.
///
/// ============================================================
/// KEY CONCEPTS FOR EVERYONE
/// ============================================================
///
/// WHAT IS A POOL?
/// A pool is a collection of assets managed together to generate returns.
/// Think of it like a mutual fund or investment vehicle.
///
/// Examples:
/// - "US Real Estate Fund" - Pool investing in tokenized US real estate
/// - "Corporate Bond Fund" - Pool investing in corporate debt
/// - "Stablecoin Yield Fund" - Pool lending stablecoins for yield
///
/// Each pool has:
/// - A unique ID (generated by this registry)
/// - A base currency (e.g., USDC) for pricing everything
/// - One or more managers who can operate the pool
/// - Metadata (name, description, etc.)
///
/// WHAT IS AN ASSET?
/// An asset is any ERC20 token that can be deposited into pools.
/// Before a token can be used, it must be registered here.
///
/// Examples:
/// - USDC (ID: 1, decimals: 6)
/// - WETH (ID: 2, decimals: 18)
/// - DAI (ID: 3, decimals: 18)
///
/// WHY REGISTER ASSETS?
/// - Assign a protocol-wide ID (used in cross-chain messages)
/// - Store decimal information (needed for price calculations)
/// - Whitelist tokens that can be used in the protocol
///
/// ============================================================
/// POOL ID FORMAT
/// ============================================================
///
/// Pool IDs are 64-bit integers with a special format:
///
/// ┌─────────────────┬─────────────────────────────────────┐
/// │  Chain ID (16)  │     Sequential Counter (48)         │
/// └─────────────────┴─────────────────────────────────────┘
///
/// Upper 16 bits: Chain ID where pool was created
/// - Arbitrum One: 42161 (0xA4B1)
/// - This identifies the hub chain
///
/// Lower 48 bits: Sequential counter
/// - Increments for each new pool
/// - Allows 281+ trillion pools per chain
///
/// EXAMPLE:
/// First pool on Arbitrum:
/// - Chain ID: 42161 = 0xA4B1
/// - Counter: 1
/// - Pool ID: 0xA4B1_000000000001
///
/// WHY THIS FORMAT?
/// - Guarantees uniqueness across chains (if we ever migrate)
/// - Easy to identify which chain a pool was created on
/// - Counter ensures no collisions within a chain
///
/// ============================================================
/// MANAGER PERMISSIONS
/// ============================================================
///
/// Each pool has one or more "managers" who can:
/// - Create share classes
/// - Start/execute epochs
/// - Update holdings and valuations
/// - Broadcast prices to spoke chains
///
/// IMPORTANT: Managers are NOT the same as contract admins (wards).
/// - Wards: Can modify the registry itself (add assets, etc.)
/// - Managers: Can operate specific pools they're assigned to
///
/// This separation allows:
/// - Protocol admins to control the registry
/// - Pool operators to manage their own pools
/// - Fine-grained access control
///
/// ============================================================
/// HUB REQUEST MANAGERS
/// ============================================================
///
/// Each pool can have different "hub request managers" for each network.
/// These are contracts that handle incoming requests from that network.
///
/// Example:
/// Pool #1 might have:
/// - Ethereum (ID: 1): 0xabc... handles Ethereum requests
/// - Base (ID: 8453): 0xdef... handles Base requests
///
/// This allows pools to customize how they handle requests
/// from different spoke chains.
///
contract RiyzoRegistry is Auth, IRiyzoRegistry {
    // ============================================================
    // STORAGE - POOLS
    // ============================================================

    /// @notice Sequential counter for generating pool IDs
    /// @dev Only the lower 48 bits are used
    uint48 internal _poolCounter;

    /// @notice Tracks which pools exist
    /// @dev poolExists[poolId] => bool
    mapping(uint64 => bool) internal _poolExists;

    /// @notice Base currency for each pool
    /// @dev poolCurrency[poolId] => assetId
    ///
    /// The currency is the "unit of account" for the pool.
    /// All prices and NAV calculations are in this currency.
    mapping(uint64 => uint128) internal _poolCurrency;

    /// @notice Pool metadata (arbitrary bytes, usually JSON)
    /// @dev poolMetadata[poolId] => bytes
    mapping(uint64 => bytes) internal _poolMetadata;

    /// @notice Manager permissions per pool
    /// @dev poolManagers[poolId][manager] => isManager
    mapping(uint64 => mapping(address => bool)) internal _poolManagers;

    /// @notice Hub request manager per pool per network
    /// @dev hubRequestManagers[poolId][centrifugeId] => manager address
    mapping(uint64 => mapping(uint16 => address)) internal _hubRequestManagers;

    // ============================================================
    // STORAGE - ASSETS
    // ============================================================

    /// @notice Sequential counter for generating asset IDs
    uint128 internal _assetCounter;

    /// @notice Tracks which assets are registered
    /// @dev assetRegistered[assetId] => bool
    mapping(uint128 => bool) internal _assetRegistered;

    /// @notice Decimals for each asset
    /// @dev assetDecimals[assetId] => decimals
    mapping(uint128 => uint8) internal _assetDecimals;

    /// @notice Token address for each asset ID
    /// @dev assetAddress[assetId] => address
    mapping(uint128 => address) internal _assetAddress;

    /// @notice Asset ID for each token address
    /// @dev addressToAssetId[address] => assetId
    mapping(address => uint128) internal _addressToAssetId;

    // ============================================================
    // CONSTRUCTOR
    // ============================================================

    /// @notice Initialize the RiyzoRegistry contract
    /// @param initialWard Address that will have admin rights
    constructor(address initialWard) Auth(initialWard) {}

    // ============================================================
    // POOL REGISTRATION
    // ============================================================

    /// @inheritdoc IRiyzoRegistry
    /// @dev Registers a new pool in the protocol.
    ///
    /// HOW POOL ID IS GENERATED:
    /// 1. Get current chain ID (42161 for Arbitrum)
    /// 2. Increment pool counter
    /// 3. Combine: (chainId << 48) | counter
    ///
    /// EXAMPLE:
    /// - Chain ID: 42161 = 0xA4B1
    /// - Counter: 1
    /// - Result: (0xA4B1 << 48) | 1 = 0xA4B1000000000001
    function registerPool(uint128 currencyAssetId, address admin) external auth returns (uint64 poolId) {
        // ============================================================
        // STEP 1: Validate currency is registered
        // ============================================================
        if (!_assetRegistered[currencyAssetId]) {
            revert CurrencyNotRegistered(currencyAssetId);
        }

        // ============================================================
        // STEP 2: Generate pool ID with chain prefix
        // ============================================================
        // Increment counter (starts at 1)
        uint48 counter = ++_poolCounter;

        // Combine chain ID and counter
        // Upper 16 bits: chain ID
        // Lower 48 bits: counter
        // Using block.chainid ensures uniqueness across chains
        // Casting is safe: block.chainid fits in uint16 for known chains
        // forge-lint: disable-next-line(unsafe-typecast)
        poolId = (uint64(uint16(block.chainid)) << 48) | uint64(counter);

        // ============================================================
        // STEP 3: Initialize pool state
        // ============================================================
        _poolExists[poolId] = true;
        _poolCurrency[poolId] = currencyAssetId;

        // ============================================================
        // STEP 4: Grant manager role to admin
        // ============================================================
        _poolManagers[poolId][admin] = true;

        emit PoolRegistered(poolId, currencyAssetId, admin);
        emit ManagerUpdated(poolId, admin, true);

        return poolId;
    }

    // ============================================================
    // ASSET REGISTRATION
    // ============================================================

    /// @inheritdoc IRiyzoRegistry
    /// @dev Registers a new asset (ERC20 token) in the protocol.
    ///
    /// WHY REGISTER ASSETS?
    /// - Assign a compact numeric ID (for cross-chain messages)
    /// - Store decimals (needed for price calculations)
    /// - Whitelist tokens that can be used
    ///
    /// ASSET ID:
    /// Simple incrementing counter starting at 1.
    /// Asset ID 0 is reserved/invalid.
    function registerAsset(address asset, uint8 assetDecimals) external auth returns (uint128 assetId) {
        // ============================================================
        // STEP 1: Validate asset address
        // ============================================================
        if (asset == address(0)) {
            revert InvalidAssetAddress();
        }

        // ============================================================
        // STEP 2: Check not already registered
        // ============================================================
        if (_addressToAssetId[asset] != 0) {
            revert AssetAlreadyRegistered(_addressToAssetId[asset]);
        }

        // ============================================================
        // STEP 3: Generate asset ID
        // ============================================================
        // Increment counter (starts at 1, ID 0 is reserved)
        assetId = ++_assetCounter;

        // ============================================================
        // STEP 4: Store asset data
        // ============================================================
        _assetRegistered[assetId] = true;
        _assetDecimals[assetId] = assetDecimals;
        _assetAddress[assetId] = asset;
        _addressToAssetId[asset] = assetId;

        emit AssetRegistered(assetId, asset, assetDecimals);

        return assetId;
    }

    // ============================================================
    // MANAGER MANAGEMENT
    // ============================================================

    /// @inheritdoc IRiyzoRegistry
    /// @dev Adds or removes a manager for a pool.
    ///
    /// WHO CAN CALL THIS?
    /// - Contract wards (admins)
    /// - Existing managers of the pool could also be allowed
    ///   (depends on governance design)
    ///
    /// WHAT CAN MANAGERS DO?
    /// - Create share classes
    /// - Execute epochs
    /// - Update holdings
    /// - Broadcast prices
    function updateManager(uint64 poolId, address manager, bool isManager_) external auth {
        // ============================================================
        // STEP 1: Verify pool exists
        // ============================================================
        if (!_poolExists[poolId]) {
            revert PoolNotFound(poolId);
        }

        // ============================================================
        // STEP 2: Update manager status
        // ============================================================
        _poolManagers[poolId][manager] = isManager_;

        emit ManagerUpdated(poolId, manager, isManager_);
    }

    // ============================================================
    // POOL CONFIGURATION
    // ============================================================

    /// @inheritdoc IRiyzoRegistry
    /// @dev Sets arbitrary metadata for a pool.
    ///
    /// METADATA FORMAT:
    /// Typically JSON-encoded data containing:
    /// - Pool name
    /// - Description
    /// - Risk disclosures
    /// - External links
    ///
    /// EXAMPLE:
    /// {"name": "US Real Estate Fund", "description": "...", "website": "..."}
    function setPoolMetadata(uint64 poolId, bytes calldata metadata) external auth {
        // ============================================================
        // STEP 1: Verify pool exists
        // ============================================================
        if (!_poolExists[poolId]) {
            revert PoolNotFound(poolId);
        }

        // ============================================================
        // STEP 2: Store metadata
        // ============================================================
        _poolMetadata[poolId] = metadata;

        emit PoolMetadataUpdated(poolId, metadata);
    }

    /// @inheritdoc IRiyzoRegistry
    /// @dev Sets the hub request manager for a specific network.
    ///
    /// WHAT IS A HUB REQUEST MANAGER?
    /// A contract that handles incoming requests from a specific spoke chain.
    /// Each pool can have different handlers for different networks.
    ///
    /// WHY PER-NETWORK?
    /// - Different networks might have different request formats
    /// - Allows upgrades per-network without affecting others
    /// - Pools can customize handling per network
    function setHubRequestManager(uint64 poolId, uint16 centrifugeId, address manager) external auth {
        // ============================================================
        // STEP 1: Verify pool exists
        // ============================================================
        if (!_poolExists[poolId]) {
            revert PoolNotFound(poolId);
        }

        // ============================================================
        // STEP 2: Store manager
        // ============================================================
        _hubRequestManagers[poolId][centrifugeId] = manager;

        emit HubRequestManagerSet(poolId, centrifugeId, manager);
    }

    // ============================================================
    // VIEW FUNCTIONS - POOLS
    // ============================================================

    /// @inheritdoc IRiyzoRegistry
    function exists(uint64 poolId) external view returns (bool) {
        return _poolExists[poolId];
    }

    /// @inheritdoc IRiyzoRegistry
    function isManager(uint64 poolId, address manager) external view returns (bool) {
        return _poolManagers[poolId][manager];
    }

    /// @inheritdoc IRiyzoRegistry
    function currency(uint64 poolId) external view returns (uint128 assetId) {
        if (!_poolExists[poolId]) {
            revert PoolNotFound(poolId);
        }
        return _poolCurrency[poolId];
    }

    /// @inheritdoc IRiyzoRegistry
    function getPoolMetadata(uint64 poolId) external view returns (bytes memory metadata) {
        if (!_poolExists[poolId]) {
            revert PoolNotFound(poolId);
        }
        return _poolMetadata[poolId];
    }

    /// @inheritdoc IRiyzoRegistry
    function getHubRequestManager(uint64 poolId, uint16 centrifugeId) external view returns (address manager) {
        if (!_poolExists[poolId]) {
            revert PoolNotFound(poolId);
        }
        return _hubRequestManagers[poolId][centrifugeId];
    }

    /// @inheritdoc IRiyzoRegistry
    function poolCounter() external view returns (uint48 counter) {
        return _poolCounter;
    }

    // ============================================================
    // VIEW FUNCTIONS - ASSETS
    // ============================================================

    /// @inheritdoc IRiyzoRegistry
    function decimals(uint128 assetId) external view returns (uint8 assetDecimals) {
        if (!_assetRegistered[assetId]) {
            revert AssetNotRegistered(assetId);
        }
        return _assetDecimals[assetId];
    }

    /// @inheritdoc IRiyzoRegistry
    function getAssetAddress(uint128 assetId) external view returns (address asset) {
        if (!_assetRegistered[assetId]) {
            revert AssetNotRegistered(assetId);
        }
        return _assetAddress[assetId];
    }

    /// @inheritdoc IRiyzoRegistry
    function getAssetId(address asset) external view returns (uint128 assetId) {
        return _addressToAssetId[asset];
    }

    /// @inheritdoc IRiyzoRegistry
    function isRegistered(uint128 assetId) external view returns (bool registered) {
        return _assetRegistered[assetId];
    }

    /// @inheritdoc IRiyzoRegistry
    function assetCounter() external view returns (uint128 counter) {
        return _assetCounter;
    }

    // ============================================================
    // HELPER FUNCTIONS
    // ============================================================

    /// @notice Extract chain ID from a pool ID
    /// @dev Upper 16 bits of pool ID contain chain ID
    /// @param poolId Pool identifier
    /// @return chainId The chain ID where pool was created
    function getPoolChainId(uint64 poolId) external pure returns (uint16 chainId) {
        // Casting is safe: we're extracting the upper 16 bits which fit in uint16
        // forge-lint: disable-next-line(unsafe-typecast)
        return uint16(poolId >> 48);
    }

    /// @notice Extract counter from a pool ID
    /// @dev Lower 48 bits of pool ID contain counter
    /// @param poolId Pool identifier
    /// @return counter The sequential counter value
    function getPoolCounter(uint64 poolId) external pure returns (uint48 counter) {
        // Casting is safe: we're extracting the lower 48 bits which fit in uint48
        // forge-lint: disable-next-line(unsafe-typecast)
        return uint48(poolId);
    }

    /// @notice Check if a pool was created on the current chain
    /// @param poolId Pool identifier
    /// @return isLocal True if pool's chain ID matches current chain
    function isLocalPool(uint64 poolId) external view returns (bool isLocal) {
        // Casting is safe: we're extracting the upper 16 bits which fit in uint16
        // forge-lint: disable-next-line(unsafe-typecast)
        uint16 poolChainId = uint16(poolId >> 48);
        // forge-lint: disable-next-line(unsafe-typecast)
        return poolChainId == uint16(block.chainid);
    }
}
